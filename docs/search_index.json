[
["index.html", "mmir: An R-package for Simple Biological Metric Calculations Northeast Aquatic Biologists Conference 2020 1 mmir", " mmir: An R-package for Simple Biological Metric Calculations Northeast Aquatic Biologists Conference 2020 Zachary M. Smith March 5th, 2020 1 mmir "],
["introduction.html", "2 Introduction 2.1 Objective 2.2 What is an MMI? 2.3 Need", " 2 Introduction 2.1 Objective Demonstrate the functionality provided by the mmir R-package for calculating biological metrics for the development and/or use in an MMI or IBI. 2.2 What is an MMI? Multi-Metric Indices (MMIs) or Indices of Biotic Integrity (IBIs) are models that summarize multiple aspects of a biological community of interest (e.g., richness, diversity, relative abundance, tolerance, and functional feeding group) into a single numeric or categorical value representing ecological condition. considered a robust measure of water quality becuase it represents more than a snapshot in time have been around for nearly 40 years 2.3 Need MMIs are widely used by U.S. federal and state agencies to assess water quality but there is no R-package available to simplify and standardize metric calculations. "],
["r-overview.html", "3 R Overview 3.1 R Packages 3.2 R Functions 3.3 Tidyverse", " 3 R Overview 3.1 R Packages 3.2 R Functions 3.3 Tidyverse "],
["mmir-setup.html", "4 mmir Setup 4.1 Load the Package", " 4 mmir Setup Install the Multi-Metric Index (MMI) package, mmir, that I am developing from GitHub (https://github.com/zsmith27/mmir). devtools::install_github(&quot;zsmith27/mmir&quot;) 4.1 Load the Package Once mmir is installed, load the package with library(). library(mmir) "],
["required-data-format.html", "5 Required Data Format 5.1 Required Data Format Example 5.2 Data Preparation for Integration with dplyr", " 5 Required Data Format Requirements Each row should represent the number of individuals enumerated for a single taxon collected during a single sampling event. There should be columns representing: a unique ID for a sampling event (i.e., key) taxonomic counts various taxonomic ranks (e.g., individual columns for order, family, genus) various taxonomic groups (e.g., tolerance values and functional feeding groups) 5.1 Required Data Format Example ## Warning in instance$preRenderHook(instance): It seems your data is too big ## for client-side DataTables. You may consider server-side processing: https:// ## rstudio.github.io/DT/server.html 5.2 Data Preparation for Integration with dplyr Prepare the data for metric calculation. nest.df &lt;- nrsa_nap_0809 %&gt;% dplyr::group_nest(uid, rt_nrsa_cat, .key = &quot;data&quot;) ## Warning in instance$preRenderHook(instance): It seems your data is too big ## for client-side DataTables. You may consider server-side processing: https:// ## rstudio.github.io/DT/server.html "],
["metrics.html", "6 Metrics 6.1 Metric Function List 6.2 Metric Function Arguements 6.3 Metric Function Output", " 6 Metrics Metrics: a measure of a specific aspect of a biological community. 6.1 Metric Function List All of the metric functions in mmir begin with the prefix taxa_. This prefix makes it easier to call these functions becuase RStudio will provide a list of functions that begin with the same prefix, in this case taxa_. taxa_rich()calculates taxonomic richness. taxa_pct_rich() calculates relative taxonomic richness. taxa_div() calculates taxonomic diversity indices. shannon Shannon-Wiener Diversity simpson Simpson’s Diversity margalef Margalef’s Diversity menhinick Menhinick’s Diversity pielou Pielou Evenness taxa_abund() calculates taxonomic abundance. taxa_pct() calculates relative taxonomic abundance. taxa_dom() calculates relative taxonomic dominance. taxa_tol_index() calculates taxonomic tolerance indices. 6.2 Metric Function Arguements .dataframe = A data frame where each row should represent the number of individuals enumerated for a single taxon collected during a single sampling event. .key_col = One unquoted column name that represents a key (i.e., unique ID) for a sampling event for which to group (i.e., aggregate) the data. .counts_col = One unquoted column name that represents taxonomic counts. .filter = A logical statement to subset the data frame prior to calculating the metric of interest. .unnest_col = One unqouted column name that represents nested data. If this column is NULL (default), then the data will not be unnested. .group_col = One unquoted column name that represents a taxomic rank or group of interest. 6.3 Metric Function Output The output of each of these functions will be a vector. Vector Example: 10, 1, 13, 15, 2, 6, 7 "],
["richness-metrics.html", "7 Richness Metrics 7.1 Community Richness 7.2 Subset Richness", " 7 Richness Metrics Richness refers to the number of unique taxa. Typically, richness is used to refer to the number of unique species found in a sample but richness can be calculated for any taxonomic rank (e.g., order, family, genus). 7.1 Community Richness rich.df &lt;- nest.df %&gt;% dplyr::mutate( rich_family = taxa_rich(.dataframe = ., .key_col = uid, .counts_col = total, .group_col = family, .unnest_col = data), rich_genus = taxa_rich(.dataframe = ., .key_col = uid, .counts_col = total, .group_col = genus, .unnest_col = data) ) ## Warning in instance$preRenderHook(instance): It seems your data is too big ## for client-side DataTables. You may consider server-side processing: https:// ## rstudio.github.io/DT/server.html 7.2 Subset Richness sub_rich.df &lt;- nest.df %&gt;% dplyr::mutate( rich_ephemeroptera_fam = taxa_rich(.dataframe = ., .key_col = uid, .counts_col = total, .group_col = family, .filter = order %in% &quot;ephemeroptera&quot;, .unnest_col = data), rich_ephemeroptera_gen = taxa_rich(.dataframe = ., .key_col = uid, .counts_col = total, .group_col = genus, .filter = order %in% &quot;ephemeroptera&quot;, .unnest_col = data), rich_ept_gen = taxa_rich(.dataframe = ., .key_col = uid, .counts_col = total, .group_col = genus, .filter = order %in% c(&quot;ephemeroptera&quot;, &quot;plecoptera&quot;, &quot;trichoptera&quot;), .unnest_col = data) ) ## Warning in instance$preRenderHook(instance): It seems your data is too big ## for client-side DataTables. You may consider server-side processing: https:// ## rstudio.github.io/DT/server.html "],
["diversity-metrics.html", "8 Diversity Metrics 8.1 Community Diversity 8.2 Subset Diverstiy", " 8 Diversity Metrics Diversity metric in general combine the measure of taxonomic evenness and taxonomic richness. A number of diversity metrics can be calculated using taxa_div(): Shannon-Wiener Diversity (“shannon”) Simpson’s Diversity (“simpson”) Margalef’s Diversity (“margalef”) Menhinick’s Diversity (“menhinick”) Pielou Evenness (“pielou”) 8.1 Community Diversity div.df &lt;- nest.df %&gt;% dplyr::mutate( shannon_genus = taxa_div(.dataframe = ., .key_col = uid, .counts_col = total, .group_col = genus, .job = &quot;shannon&quot;, .base_log = 2, .unnest_col = data), simpson_genus = taxa_div(.dataframe = ., .key_col = uid, .counts_col = total, .group_col = genus, .job = &quot;simpson&quot;, .unnest_col = data), margalef_genus = taxa_div(.dataframe = ., .key_col = uid, .counts_col = total, .group_col = genus, .job = &quot;margalef&quot;, .unnest_col = data), menhinick_genus = taxa_div(.dataframe = ., .key_col = uid, .counts_col = total, .group_col = genus, .job = &quot;menhinick&quot;, .unnest_col = data), pielou_genus = taxa_div(.dataframe = ., .key_col = uid, .counts_col = total, .group_col = genus, .job = &quot;pielou&quot;, .unnest_col = data) ) ## Warning in instance$preRenderHook(instance): It seems your data is too big ## for client-side DataTables. You may consider server-side processing: https:// ## rstudio.github.io/DT/server.html 8.2 Subset Diverstiy sub_div.df &lt;- nest.df %&gt;% dplyr::mutate( simpson_gen_ept = taxa_div(.dataframe = ., .key_col = uid, .counts_col = total, .group_col = genus, .filter = order %in% c(&quot;ephemeroptera&quot;, &quot;plecoptera&quot;, &quot;trichoptera&quot;), .job = &quot;simpson&quot;, .unnest_col = data)) ## Warning in instance$preRenderHook(instance): It seems your data is too big ## for client-side DataTables. You may consider server-side processing: https:// ## rstudio.github.io/DT/server.html "],
["relative-abundance-metrics.html", "9 Relative Abundance (%) Metrics", " 9 Relative Abundance (%) Metrics Generally, abundance metrics are better represented on a normalized scale. Calculating the relative abundance (percentage) of a subset metrics should provide a more robust measure than raw abundance measures. pct.df &lt;- nest.df %&gt;% dplyr::mutate( pct_ephemeroptera = taxa_pct(.dataframe = ., .key_col = uid, .counts_col = total, .filter = order %in% &quot;ephemeroptera&quot;, .unnest_col = data), pct_ept = taxa_pct(.dataframe = ., .key_col = uid, .counts_col = total, .filter = order %in% c(&quot;ephemeroptera&quot;, &quot;plecoptera&quot;, &quot;trichoptera&quot;), .unnest_col = data), pct_shred = taxa_pct(.dataframe = ., .key_col = uid, .counts_col = total, .filter = grepl(&quot;sh&quot;, ffg), .unnest_col = data) ) ## Warning in instance$preRenderHook(instance): It seems your data is too big ## for client-side DataTables. You may consider server-side processing: https:// ## rstudio.github.io/DT/server.html "],
["sequence-through-multiple-metrics.html", "10 Sequence Through Multiple Metrics", " 10 Sequence Through Multiple Metrics seq.df &lt;- nest.df %&gt;% bind_cols( taxa_seq(.dataframe = ., .key_col = uid, .counts_col = total, .filter_cols_vec = c(&quot;class&quot;, &quot;order&quot;), .group_col = genus, .job = &quot;rich&quot;, .unnest_col = data)) ## Warning in instance$preRenderHook(instance): It seems your data is too big ## for client-side DataTables. You may consider server-side processing: https:// ## rstudio.github.io/DT/server.html seq_mult.df &lt;- nest.df %&gt;% bind_cols( taxa_seq(.dataframe = ., .key_col = uid, .counts_col = total, .filter_cols_vec = c(&quot;class&quot;, &quot;order&quot;, &quot;family&quot;), .group_col = genus, .job = &quot;rich&quot;, .unnest_col = data), taxa_seq(.dataframe = ., .key_col = uid, .counts_col = total, .filter_cols_vec = c(&quot;class&quot;, &quot;order&quot;, &quot;family&quot;), .group_col = genus, .job = &quot;pct&quot;, .unnest_col = data), taxa_seq(.dataframe = ., .key_col = uid, .counts_col = total, .filter_cols_vec = c(&quot;class&quot;, &quot;order&quot;, &quot;family&quot;), .group_col = genus, .base_log = 2, .job = &quot;shannon&quot;, .unnest_col = data)) ## Warning in instance$preRenderHook(instance): It seems your data is too big ## for client-side DataTables. You may consider server-side processing: https:// ## rstudio.github.io/DT/server.html "],
["brining-it-all-together.html", "11 Brining it All Together 11.1 Metric Calculation 11.2 Metric Selection", " 11 Brining it All Together library(mmir) library(tidyverse) library(rsample) library(recipes) library(parsnip) library(workflows) library(yardstick) library(themis) Prepare the data for metric calculation. data(&quot;nrsa_nap_0809&quot;) nest.df &lt;- nrsa_nap_0809 %&gt;% group_nest(uid, rt_nrsa_cat, .key = &quot;data&quot;) 11.1 Metric Calculation The following code-chunk will produce more than 1,000 biological metrics. metrics.df &lt;- nest.df %&gt;% dplyr::mutate( rich_family = taxa_rich(.dataframe = ., .key_col = uid, .group_col = family, .unnest_col = data), rich_genus = taxa_rich(.dataframe = ., .key_col = uid, .group_col = genus, .unnest_col = data), rich_target_taxon = taxa_rich(.dataframe = ., .key_col = uid, .group_col = target_taxon, .unnest_col = data), gini_simpson_ept = taxa_div(.dataframe = ., .key_col = uid, .counts_col = total, .group_col = target_taxon, .filter = order %in% c(&quot;ephemeroptera&quot;, &quot;plecoptera&quot;, &quot;trichoptera&quot;), .job = &quot;gini_simpson&quot;, .unnest_col = data), simpson_ept = taxa_div(.dataframe = ., .key_col = uid, .counts_col = total, .group_col = target_taxon, .filter = order %in% c(&quot;ephemeroptera&quot;, &quot;plecoptera&quot;, &quot;trichoptera&quot;), .job = &quot;simpson&quot;, .unnest_col = data), shannon_ept = taxa_div(.dataframe = ., .key_col = uid, .counts_col = total, .group_col = target_taxon, .filter = order %in% c(&quot;ephemeroptera&quot;, &quot;plecoptera&quot;, &quot;trichoptera&quot;), .job = &quot;shannon&quot;, .base_log = 2, .unnest_col = data), pct_ept = taxa_pct(.dataframe = ., .key_col = uid, .counts_col = total, .filter = order %in% c(&quot;ephemeroptera&quot;, &quot;plecoptera&quot;, &quot;trichoptera&quot;), .unnest_col = data), pct_cote = taxa_pct(.dataframe = ., .key_col = uid, .counts_col = total, .filter = order %in% c(&quot;coleoptera&quot;, &quot;odonata&quot;, &quot;trichoptera&quot;, &quot;ephemeroptera&quot;), .unnest_col = data), dom_1_target_taxon = taxa_dom(.dataframe = ., .key_col = uid, .counts_col = total, .group_col = target_taxon, .dom_level = 1, .unnest_col = data), dom_5_target_taxon = taxa_dom(.dataframe = ., .key_col = uid, .counts_col = total, .group_col = target_taxon, .dom_level = 5, .unnest_col = data), tol_index = taxa_tol_index(.dataframe = ., .key_col = uid, .counts_col = total, .tol_col = ptv, .unnest_col = data) ) %&gt;% dplyr::bind_cols( taxa_seq(.dataframe = ., .key_col = uid, .counts_col = total, .filter_cols_vec = c(&quot;class&quot;, &quot;order&quot;, &quot;family&quot;, &quot;ffg&quot;, &quot;habit&quot;, &quot;voltinism&quot;), .group_col = target_taxon, .job = &quot;rich&quot;, .unnest_col = data), taxa_seq(.dataframe = ., .key_col = uid, .counts_col = total, .filter_cols_vec = c(&quot;class&quot;, &quot;order&quot;, &quot;family&quot;, &quot;ffg&quot;, &quot;habit&quot;, &quot;voltinism&quot;), .group_col = target_taxon, .job = &quot;pct_rich&quot;, .unnest_col = data), taxa_seq(.dataframe = ., .key_col = uid, .counts_col = total, .filter_cols_vec = c(&quot;class&quot;, &quot;order&quot;, &quot;family&quot;, &quot;genus&quot;, &quot;ffg&quot;, &quot;habit&quot;, &quot;voltinism&quot;), .job = &quot;pct&quot;, .unnest_col = data), taxa_seq(.dataframe = ., .key_col = uid, .counts_col = total, .filter_cols_vec = c(&quot;class&quot;, &quot;order&quot;, &quot;family&quot;, &quot;ffg&quot;, &quot;habit&quot;, &quot;voltinism&quot;), .group_col = target_taxon, .job = &quot;simpson&quot;, .unnest_col = data), ) 11.2 Metric Selection 11.2.1 Train/Test Split set.seed(42) train_test_split &lt;- metrics.df %&gt;% select(-data) %&gt;% filter(!rt_nrsa_cat %in% &quot;intermediate disturbance&quot;) %&gt;% mutate(rt_nrsa_cat = str_replace_all(rt_nrsa_cat, &quot; &quot;, &quot;_&quot;), rt_nrsa_cat = factor(rt_nrsa_cat, levels = c(&quot;most_disturbed&quot;, &quot;least_disturbed&quot;))) %&gt;% initial_split() train.df &lt;- training(train_test_split) test.df &lt;- testing(train_test_split) 11.2.2 Preprocess rec_obj &lt;- recipe(rt_nrsa_cat ~ ., data = train.df) %&gt;% update_role(uid, new_role = &quot;sample_id&quot;) %&gt;% step_normalize(all_predictors()) %&gt;% step_nzv(all_predictors()) %&gt;% step_corr(all_predictors(), threshold = 0.75, method = &quot;spearman&quot;) %&gt;% step_pca(all_predictors(), num_comp = 4) %&gt;% step_adasyn(rt_nrsa_cat, neighbors = 5) %&gt;% prep() pca_results.df &lt;- rec_obj %&gt;% tidy(number = 4) 11.2.3 Model logit_mod &lt;- logistic_reg() %&gt;% set_engine(&quot;glm&quot;) met.flow &lt;- workflow() %&gt;% add_recipe(rec_obj) %&gt;% add_model(logit_mod) (fit_train &lt;- fit(met.flow, data = train.df)) ## == Workflow [trained] ========================================================== ## Preprocessor: Recipe ## Model: logistic_reg() ## ## -- Preprocessor ---------------------------------------------------------------- ## 5 Recipe Steps ## ## * step_normalize() ## * step_nzv() ## * step_corr() ## * step_pca() ## * step_adasyn() ## ## -- Model ----------------------------------------------------------------------- ## ## Call: stats::glm(formula = formula, family = stats::binomial, data = data) ## ## Coefficients: ## (Intercept) PC1 PC2 PC3 PC4 ## -0.99023 0.44787 -0.06578 0.07064 -0.20949 ## ## Degrees of Freedom: 99 Total (i.e. Null); 95 Residual ## Null Deviance: 138.6 ## Residual Deviance: 58.38 AIC: 68.38 11.2.3.1 Predictions pred_train &lt;- predict(fit_train, new_data = train.df, type = &quot;prob&quot;) %&gt;% bind_cols(select(train.df, rt_nrsa_cat)) pred_test &lt;- predict(fit_train, new_data = test.df, type = &quot;prob&quot;) %&gt;% bind_cols(select(test.df, rt_nrsa_cat)) ggplot(pred_test, aes(.pred_least_disturbed, as.numeric(rt_nrsa_cat) - 1)) + geom_point() + stat_smooth( method = &quot;glm&quot;, se = FALSE, method.args = list(family = binomial)) simple_glm_roc &lt;- pred_train %&gt;% roc_curve(rt_nrsa_cat, .pred_least_disturbed) pred_train %&gt;% roc_auc(rt_nrsa_cat, .pred_least_disturbed) ## # A tibble: 1 x 3 ## .metric .estimator .estimate ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 roc_auc binary 0.904 autoplot(simple_glm_roc) "],
["acknowledgements.html", "12 Acknowledgements", " 12 Acknowledgements Interstate Commission on the Potomac River Basin (ICPRB) With a special thank you to Dr. Claire Buchanan New York State Department of Environmental Conservation (NYSDEC) With a special thank you to Dr. Alexander J. Smith "],
["contact-information.html", "13 Contact Information", " 13 Contact Information Name: Zachary M. Smith Email: zachary.smith2@dec.ny.gov GitHub: https://github.com/zsmith27 mmir: https://github.com/zsmith27/mmir "]
]
